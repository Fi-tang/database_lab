/**
 * @file    executor.h
 * @author  liugang(liugang@ict.ac.cn)
 * @version 0.1
 *
 * @section DESCRIPTION
 *
 * definition of executor
 *
 */

#ifndef _EXECUTOR_H
#define _EXECUTOR_H

#include "catalog.h"
#include "mymemory.h"

/** aggrerate method. */
enum AggrerateMethod
{
  NONE_AM = 0, /**< none */
  COUNT,       /**< count of rows */
  SUM,         /**< sum of data */
  AVG,         /**< average of data */
  MAX,         /**< maximum of data */
  MIN,         /**< minimum of data */
  MAX_AM
};

/** compare method. */
enum CompareMethod
{
  NONE_CM = 0,
  LT,   /**< less than */
  LE,   /**< less than or equal to */
  EQ,   /**< equal to */
  NE,   /**< not equal than */
  GT,   /**< greater than */
  GE,   /**< greater than or equal to */
  LINK, /**< join */
  MAX_CM
};

/** definition of request column. */
struct RequestColumn
{
  char name[128];                   /**< name of column */
  AggrerateMethod aggrerate_method; /** aggrerate method, could be NONE_AM  */
};

/** definition of request table. */
struct RequestTable
{
  char name[128]; /** name of table */
};

/** definition of compare condition. */
struct Condition
{
  RequestColumn column;  /**< which column */
  CompareMethod compare; /**< which method */
  char value[128];       /**< the value to compare with, if compare==LINK,value is another column's name; else it's the column's value*/
};

/** definition of conditions. */
struct Conditions
{
  int condition_num;      /**< number of condition in use */
  Condition condition[4]; /**< support maximum 4 & conditions */
};

/** definition of selectquery.  */
class SelectQuery
{
public:
  int64_t database_id;            /**< database to execute */
  int select_number;              /**< number of column to select */
  RequestColumn select_column[4]; /**< columns to select, maximum 4 */
  int from_number;                /**< number of tables to select from */
  RequestTable from_table[4];     /**< tables to select from, maximum 4 */
  Conditions where;               /**< where meets conditions, maximum 4 & conditions */
  int groupby_number;             /**< number of columns to groupby */
  RequestColumn groupby[4];       /**< columns to groupby */
  Conditions having;              /**< groupby conditions */
  int orderby_number;             /**< number of columns to orderby */
  RequestColumn orderby[4];       /**< columns to orderby */
};                                // class SelectQuery

/** definition of result table.  */
class ResultTable
{
public:
  int column_number;       /**< columns number that a result row consist of */
  BasicType **column_type; /**< each column data type */
  char *buffer;            /**< pointer of buffer alloced from g_memory */
  int64_t buffer_size;     /**< size of buffer, power of 2 */
  int row_length;          /**< length per result row */
  int row_number;          /**< current usage of rows */
  int row_capicity;        /**< maximum capicity of rows according to buffer size and length of row */
  int *offset;
  int offset_size;

  /**
   * init alloc memory and set initial value
   * @col_types array of column type pointers
   * @col_num   number of columns in this ResultTable
   * @param  capicity buffer_size, power of 2
   * @retval >0  success
   * @retval <=0  failure
   */
  int init(BasicType *col_types[], int col_num, int64_t capicity = 1024*1024);
  /**
   * calculate the char pointer of data spcified by row and column id
   * you should set up column_type,then call init function
   * @param row    row id in result table
   * @param column column id in result table
   * @retval !=NULL pointer of a column
   * @retval ==NULL error
   */
  char *getRC(int row, int column);
  /**
   * write data to position row,column
   * @param row    row id in result table
   * @param column column id in result table
   * @data data pointer of a column
   * @retval !=NULL pointer of a column
   * @retval ==NULL error
   */
  int writeRC(int row, int column, void *data);
  /**
   * print result table, split by '\t', output a line per row
   * @retval the number of rows printed
   */
  int print(void);
  /**
   * write to file with FILE *fp
   */
  int dump(FILE *fp);
  /**
   * free memory of this result table to g_memory
   */
  int shut(void);
}; // class ResultTable

/** definition of class executor.  */
class Executor
{
private:
  SelectQuery *current_query; /**< selectquery to iterately execute */
public:
  /**
   * exec function.
   * @param  query to execute, if NULL, execute query at last time
   * @param result table generated by an execution, store result in pattern defined by the result table
   * @retval >0  number of result rows stored in result
   * @retval <=0 no more result
   */
  virtual int exec(SelectQuery *query, ResultTable *result);
  //--------------------------------------
  //  ...
  //  ...
  /**
   * close function.
   * @param None
   * @retval ==0 succeed to close
   * @retval !=0 fail to close
   */
  virtual int close();
};

//  you may refer to the following code.
/** definition of Class Operator. */ 
class Operator
{
public:
  void *lchild;                   /**< lchild, points out the lchild of current Operator, lchild is also an Operator */
  void *rchild;                   /**< rchild, points out the lchild of current Operator, lchild is also an Operator */
  void *parent;                   /**< parent, points out the parent node of current Operator, not use here, become it's top-down */
  RPattern row_column_RPattern;   /**< define the output format,only record data_type and it's arrangement in output result */
  std::vector<int64_t> Column_id_array; /**<same function as catalog.h Key, record column_id,corresponding to row_column_RPattern */
  char *prev_buffer;             /**< buffer to store child node's current_buffer, receive child's output result, actually  rarely use*/
  char *current_buffer;          /**< the most important buffer, record result tuple */

 /**
  * init function
  * define the result format --> init row_column_RPattern
  * define the result (tuple)'s column_id --> init Column_id_array
  * allocate space for current_buffer
  * prepare parameters for getNext() function 
  */ 
  virtual bool init(){ return false; };  
  /**
   * getNext() function
   * usually compute the result,
   * call getNext() once, it returns a result(current_buffer)
   * if it has finished, return false;
   */  
  virtual bool getNext(){ return false; };
  /**
   * isEnd() function
   * free space for current Operator
   * usually parent's isEnd will call child's isEnd 
   */ 
  virtual bool isEnd(){ return false; };
  /**
   * print() function
   * this function is not related to function, it's used to debug
   * print the Operator tree to check the construction of Operator tree's correctness.
   * @param n means the Operator lines at the nth layer of Operator tree.
   */ 
  virtual void print(int n){ };
};

/** definition of class Scan. */
class Scan : public Operator
{
private:
  RowTable *scan_row_table;     /**< as scan is the lowest bottom of the true,it's Row_column_RPattern(format) is the same as the original table */
  int scan_table_num;           /**< how many tables the sql request. */
  int scan_count;               /**< record current lines of tuple, uesd to tag the end of GetNext(). */

public:
  /**
   * init() function.
   * @param table_name the name of the table to scan from
   * @retval true successfully init.
   * @retval false init failure.
   */ 
  bool init(char *table_name);
  /**
   * getNext() helps to record the current tuple ptr,and everytime
   * copies one from origin table to current_buffer.
   * current_buffer stores the Scan Operator result.
   * @retval true success.
   * @retval false failure.
   */ 
  bool getNext();
  /**
   * free sapce of Scan Operator.
   * @retval true getNext success.
   * @retval false getNext failure.
   */ 
  bool isEnd();
  /**
   * print Operator tree, whether Operator tree uses Scan Operator, which layer Scan Operator lies at.
   * @param n the n th layer it lies at.
   */ 
  void print(int n);
};

/** definition of class Filter. */
class Filter : public Operator
{
private:
  RequestTable from_given_table[4];                   /**< the name of tables*/
  int Column_offset[4];                               /**< record the offset of (filter column) in RPattern. */
  BasicType *column_data_type[4];                     /**< record the datatype of (filter column), INT8_TC,INT16_TC,... */

public:
  int filter_judge_num;                             /**< the number of filter conditions. */
  Condition filter_judge_condition[4];              /**< record the corrseponding conditions given to corrseponding table. */
  /**
   * init function for Filter.
   * @param filter_given_conditions record 4 buckets to store conditions, every bucket stores 4 filter condition
   * table[i]'s filter condition is stored in filter_given_condition[i]
   * @retval true success.
   * @retval false fail. 
   */ 
  bool init(Conditions filter_given_conditions); 
  /**
   * Filter's getNext(), everytime returns one result tuple.
   * @retval true success
   * @retval false failure.
   */    
  bool getNext();
  /**
   * free space used in Filter Operator.
   * @retval true success
   * @retval false failure
   */ 
  bool isEnd();
  /**
   * print Filter Operator lies in Operator tree's layer.
   * @param n the n th layer Filter Operator lies at.
   */ 
  void print(int n);
};

/** definition of Class Project */
class Project : public Operator
{
  private:
  int project_column_number;        /**< the number of Columns to project . */
  int project_column_rank[4];       /**< the rank of Project Columns in it's format(row_column_RPattern). */
  public:
    Column *project_column_id[4];   /**< the column_id of project Column.  */
    /**
     * init function of Project.
     * @param project_given_number  the number of Columns to project.
     * @param project_given_request the name of Columns to project.
     * @retval true  Project init success.
     * @retval false Project init fail.
     */ 
    bool init(int project_given_number, RequestColumn *project_given_request);
    /**
     * getNext() is used to get (lchild)'s result, and choose the
     * requested column to project.
     * @retval true Project getNext() success
     * @retval false Project getNext() failure
     */ 
    bool getNext();
    /**
     * free the space allocated to Project.
     * @retval true free success.
     * @retval false free failure.
     */ 
    bool isEnd();
    /**
     * print the layer of Project in Operator tree.
     * @param n the n th layer Project Operator lies in Operator tree.
     */
    void print(int n);
};

/** definition of Join node. */
class Join : public Operator
{
  private:
    HashInfo hf;            /**< HashInfo, refer to hashindex.h , it's uesd to lookup the hash table and record information */
    bool get_next_judge;    /**< assume we have table A and B, we build hash table on table A, and use table B to lookup,if table
                            * A has not been visited to the end, in other word, hash(Table B's one tuple) = hash_code,
                            * the hash_code in hash table(build on A ),has not been lookup to the end,then table B should not get
                            * the next tuple.
                            */
    void **data_rchild;     /**< record table B(rchild's result)'s information, the data used in hashtable. */

  public:
  int join_given_condition_num;                         /**< the number of join condition. */
  std::vector<int64_t> Column_id_array_prepare;         /**< record the column_id need to join on left table(table A). */
  std::vector<int64_t> Column_id_array_join;            /**< record the column_id need to join on right table(table B).*/
  int join_lchild_rank[4];                              /**< the offset of left table's join column's column_id in lchild's column_id_array */
  int join_rchild_rank[4];                              /**< the offset of right table's join column's column_id in lchild's column_id_array */
  HashIndex *hx;                                        /**< the index needed to build hash table. */
  std::vector<void *> insert_hash_data;                 /**< the hash_data to insert in hash table. */
  char* lookup_hash_data;                               /**< right table's data, used to lookup in hash table. */

  /**
   * init function.
   * in init phase, we need to finish the construction of hash table,
   * call hashindex.h 's  insert, setCellCap, addIndexDTpye,finsh. 
   * @param join_given_conditions the condition of join Operator,we only deal with two table's join. 
   * @retval true init success
   * @retval false init failure
   */ 
  bool init(Conditions join_given_conditions);
  /**
   * getNext() function.
   * this function call hashinex.h 's  lookup to get one tuple of successful join.
   * @retval true getNext success.
   * @retval false getNext failure.
   */ 
  bool getNext();
  /**
   * free the space allocated to Join Operator.
   * @retval true free success
   * @retval false free fail
   */ 
  bool isEnd();
  /**
   * print the Join Operator in Operator tree.
   * @param n the nth layer Join Operator lies in.
   */ 
  void print(int n);
};

/** definition of Groupby_struct.*/
struct Groupby_struct{
  char given_condition[4][1024];      /**< the array deals with groupby column and having column, if the groupby column has the
                                      * same value, then we do not need to allocate a new space, we simply conduct SUM,AVG,MIN,MAX
                                      * compute, if the groupby column is different from all the column's of given_condition,
                                      * then we add it.
                                      */ 
  char value[4][1024];                /**< store the having column's corresponding data. */
};

/** definition of Groupby Operator. */
class Groupby : public Operator
{
private:
  int groupby_number;                               /**< the number of columns to groupby. */
  int groupby_compute_num;                          /**< the number of columns which need SUM/AVG/MIN/MAX/COUNT computing. */
  int groupby_offset[4];                            /**< the offset of groupby columns in lchid's Row_column_RPattern.  */
  BasicType * groupby_data_type[4];                 /**< the data_type of groupby columns in lchild's Row_column_RPattern. */
  int groupby_compute_offset[4];                    /**< the offset of having columns in lchild's Row_column_RPattern.  */
  BasicType * groupby_compute_data_type[4];         /**< the data_type of having columns in lchild's Row_column_RPattern. */
  AggrerateMethod groupby_compute_method[4];        /**< compute type of corresponding having columns. */
  std::vector<struct Groupby_struct> groupby_vector; /**< a vector to groupby the (groupby column) which has the same value,
                                                      * and use groupby_vector[i].value to compute (having column).
                                                      */ 
  int count ;                                        /**< tag the finish of Groupby Operator. */
public:
  /**
   * init function of groupby, need to finish the construction of groupby_vector.
   * @param groupby_number  the number of columns to groupby.
   * @param groupby_conditions[4] the conditions of having column.
   * @param groupby_compute_num the number of columns of having.
   * @param groupby_column the name of groupby column.
   * @retval true init success.
   * @retval false init failure.
   */ 
  bool init(int groupby_number, RequestColumn groupby_conditions[4], int groupby_compute_num, RequestColumn groupby_column[4]);
  /**
   * get one tuple of init result.
   * @retval true  groupby suceess.
   * @retval false groupby failure.
   */ 
  bool getNext();
  /**
   * free the space allocated to groupby Operator.
   * @retval true free success.
   * @retval false free failure.
   */ 
  bool isEnd();
  /**
   * print the groupby Operator in Operator tree.
   * @param n the n th layer of Operator tree, where groupby lies at.
   */ 
  void print(int n);
};

class Orderby : public Operator
{
public:
  int orderby_offset[4];              /**< the offset of orderby column in it's lchild's Column_id_array. */
  BasicType *orderby_data_type[4];    /**< the data_type of orderby column. */
  std::vector<char *>orderby_vector;  /**< vector used for qsort. */
  int orderby_number;                 /**< number of columns to orderby. */
  RequestColumn orderby[4];           /**< name of columns to orderby.   */
  int count;                          /**< tag the current number of orderby's result tuple.  */

  /**
   * init function, also need to fill in the qsort's parameter. 
   * @param orderby_given_number   number of columns to orderby.
   * @param orderby_given          name of columns to orderby.
   * @retval true   orderby init success.
   * @retval false  orderby init failure.
   */ 
  bool init(int orderby_given_number, RequestColumn *orderby_given);
  /**
   * get one tuple at a time from orderby init function.
   * @retval true get tuple success.
   * @retval false get tuple failure or the end.
   */ 
  bool getNext();
  /**
   * free the space allocated to orderby.
   * @retval true free success.
   * @retval false free fail.
   */ 
  bool isEnd();
  /**
   * print the layer of Orderby Operator in Operator tree.
   * @param n the n th layer of Operator tree(which Orderby Operator lies at).
   */ 
  void print(int n);
};

#endif